/*
 * Copyright 2019 Rackspace US, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package main

import (
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
	"go.uber.org/zap"
	"net/http"
	"net/http/httptest"
	"os"
	"testing"
)

type MockLoader struct {
	mock.Mock
}

func (m *MockLoader) LoadAll(sourceContentPath string) error {
	m.Called(sourceContentPath)
	return nil
}

type MockSourceContent struct {
	mock.Mock
}

const mockContentPath = "source/content/path"

func (m *MockSourceContent) Prepare() (string, error) {
	m.Called()
	return mockContentPath, nil
}

func (m *MockSourceContent) Cleanup() {
	m.Called()
}

type MockGitContentBuilder struct {
	mock.Mock

	sourceContent SourceContent
}

func (b *MockGitContentBuilder) build(repository string, sha string) SourceContent {
	b.Called(repository, sha)
	return b.sourceContent
}

func TestWebhookServer_handleWebhook_Ping(t *testing.T) {
	server, loader, sourceContent, _ := createTestWebhookServer("", []string{}, false)

	reqBody, err := os.Open("testdata/webhook_ping_req.json")
	require.NoError(t, err)
	defer reqBody.Close()

	req := createWebhookReq(reqBody, "ping", "")
	resp := &httptest.ResponseRecorder{}

	server.handleWebhook(resp, req)

	assert.Equal(t, 200, resp.Code)

	// just the status code and no other interactions
	loader.AssertExpectations(t)
	sourceContent.AssertExpectations(t)
}

func TestWebhookServer_handleWebhook_PingAuth(t *testing.T) {
	server, loader, sourceContent, _ := createTestWebhookServer("notsosecret", []string{}, false)

	reqBody, err := os.Open("testdata/webhook_ping_req.json")
	require.NoError(t, err)
	defer reqBody.Close()

	// expected HMAC SHA1 generated by using
	// cat testdata/webhook_ping_req.json| openssl dgst -hex -hmac notsosecret -sha1
	req := createWebhookReq(reqBody, "ping", "sha1=537704afb3398753cce5774dd8fb4c658a54a85b")
	resp := &httptest.ResponseRecorder{}

	server.handleWebhook(resp, req)

	assert.Equal(t, 200, resp.Code)

	// just the status code and no other interactions
	loader.AssertExpectations(t)
	sourceContent.AssertExpectations(t)
}

func TestWebhookServer_handleWebhook_PingFailedAuth(t *testing.T) {
	server, loader, sourceContent, _ := createTestWebhookServer("WRONG SECRET", []string{}, false)

	reqBody, err := os.Open("testdata/webhook_ping_req.json")
	require.NoError(t, err)
	defer reqBody.Close()

	// expected HMAC SHA1 generated by using
	// cat testdata/webhook_ping_req.json| openssl dgst -hex -hmac notsosecret -sha1
	req := createWebhookReq(reqBody, "ping", "sha1=537704afb3398753cce5774dd8fb4c658a54a85b")
	resp := &httptest.ResponseRecorder{}

	server.handleWebhook(resp, req)

	assert.Equal(t, 401, resp.Code)

	// just the status code and no other interactions
	loader.AssertExpectations(t)
	sourceContent.AssertExpectations(t)
}

func TestWebhookServer_handleWebhook_PushRequest(t *testing.T) {
	server, loader, sourceContent, builder :=
		createTestWebhookServer("", []string{}, true)

	reqBody, err := os.Open("testdata/webhook_push_req.json")
	require.NoError(t, err)
	defer reqBody.Close()

	req := createWebhookReq(reqBody, "push", "")
	resp := &httptest.ResponseRecorder{}

	server.handleWebhook(resp, req)

	assert.Equal(t, 200, resp.Code)

	loader.AssertCalled(t, "LoadAll", mockContentPath)
	builder.AssertCalled(t, "build",
		"https://github.com/Rackspace-Segment-Support/test-salus-data-loader-content.git",
		"e4168647ae258ed748a8c765127c0f3595e34bf0")
	sourceContent.AssertCalled(t, "Prepare")
}

func TestWebhookServer_handleWebhook_MatchesRefExact(t *testing.T) {
	server, loader, sourceContent, builder :=
		createTestWebhookServer("",
			// declare a single ref to match
			[]string{"refs/heads/master"},
			true)

	reqBody, err := os.Open("testdata/webhook_push_req.json")
	require.NoError(t, err)
	defer reqBody.Close()

	req := createWebhookReq(reqBody, "push", "")
	resp := &httptest.ResponseRecorder{}

	server.handleWebhook(resp, req)

	assert.Equal(t, 200, resp.Code)

	loader.AssertCalled(t, "LoadAll", mockContentPath)
	builder.AssertCalled(t, "build",
		"https://github.com/Rackspace-Segment-Support/test-salus-data-loader-content.git",
		"e4168647ae258ed748a8c765127c0f3595e34bf0")
	sourceContent.AssertCalled(t, "Prepare")
}

func TestWebhookServer_handleWebhook_MatchesRefMulti(t *testing.T) {
	server, loader, sourceContent, builder :=
		createTestWebhookServer("",
			// allow for either staging or master
			[]string{"refs/heads/staging", "refs/heads/master"},
			true)

	reqBody, err := os.Open("testdata/webhook_push_req.json")
	require.NoError(t, err)
	defer reqBody.Close()

	req := createWebhookReq(reqBody, "push", "")
	resp := &httptest.ResponseRecorder{}

	server.handleWebhook(resp, req)

	assert.Equal(t, 200, resp.Code)

	loader.AssertCalled(t, "LoadAll", mockContentPath)
	builder.AssertCalled(t, "build",
		"https://github.com/Rackspace-Segment-Support/test-salus-data-loader-content.git",
		"e4168647ae258ed748a8c765127c0f3595e34bf0")
	sourceContent.AssertCalled(t, "Prepare")
}

func TestWebhookServer_handleWebhook_MatchesRefRegex(t *testing.T) {
	server, loader, sourceContent, builder :=
		createTestWebhookServer("",
			[]string{`refs/tags/v(\d+)\.(\d+)`},
			true)

	reqBody, err := os.Open("testdata/webhook_push_tag_req.json")
	require.NoError(t, err)
	defer reqBody.Close()

	req := createWebhookReq(reqBody, "push", "")
	resp := &httptest.ResponseRecorder{}

	server.handleWebhook(resp, req)

	assert.Equal(t, 200, resp.Code)

	loader.AssertCalled(t, "LoadAll", mockContentPath)
	builder.AssertCalled(t, "build",
		"https://github.com/Rackspace-Segment-Support/test-salus-data-loader-content.git",
		"1cc985fd10b43a614fafd343190e7ee871732e25")
	sourceContent.AssertCalled(t, "Prepare")
}

func TestWebhookServer_handleWebhook_MisMatchRef(t *testing.T) {
	server, loader, sourceContent, builder :=
		createTestWebhookServer("",
			// declare expected ref that doesn't match input file
			[]string{"refs/heads/staging"},
			// don't wire up expected calls
			false)

	reqBody, err := os.Open("testdata/webhook_push_req.json")
	require.NoError(t, err)
	defer reqBody.Close()

	req := createWebhookReq(reqBody, "push", "")
	resp := &httptest.ResponseRecorder{}

	server.handleWebhook(resp, req)

	assert.Equal(t, 200, resp.Code)

	loader.AssertExpectations(t)
	builder.AssertExpectations(t)
	sourceContent.AssertExpectations(t)
}

func createWebhookReq(reqBody *os.File, eventType string, webhookSecret string) *http.Request {
	req := httptest.NewRequest("POST", "/webhook", reqBody)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("X-Github-Event", eventType)
	req.Header.Set("X-Github-Delivery", "id-1")
	req.Header.Set("X-Hub-Signature", webhookSecret)
	return req
}

func createTestWebhookServer(webhookSecret string, matchingRefs []string, wireup bool) (*WebhookServer, *MockLoader, *MockSourceContent, *MockGitContentBuilder) {
	// change to NewExample to see logs
	log := zap.NewNop().Sugar()
	loader := new(MockLoader)
	sourceContent := new(MockSourceContent)
	builder := &MockGitContentBuilder{
		sourceContent: sourceContent,
	}
	server := NewWebhookServer(log, loader, 8080, builder.build, webhookSecret, matchingRefs)

	if wireup {
		builder.On("build", mock.Anything, mock.Anything).
			Return(sourceContent)
		sourceContent.On("Prepare").
			Return(mockContentPath, nil)
		sourceContent.On("Cleanup").
			Return()
		loader.On("LoadAll", mockContentPath).
			Return(nil)
	}

	return server, loader, sourceContent, builder
}
